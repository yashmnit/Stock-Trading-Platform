"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.errors = void 0;
const crypto_1 = __importDefault(require("crypto"));
const util_1 = require("util");
const passport_local_1 = require("passport-local");
const pbkdf2_1 = require("./lib/pbkdf2");
const errors = __importStar(require("./lib/errors"));
exports.errors = errors;
const authenticate_1 = require("./lib/authenticate");
const randomBytesAsync = (0, util_1.promisify)(crypto_1.default.randomBytes);
function passportLocalMongoose(schema, options) {
    const opts = {
        saltlen: 32,
        iterations: 25000,
        keylen: 512,
        encoding: 'hex',
        digestAlgorithm: 'sha256',
        usernameField: 'username',
        usernameUnique: true,
        usernameQueryFields: [],
        usernameCaseInsensitive: false,
        usernameLowerCase: false,
        hashField: 'hash',
        saltField: 'salt',
        limitAttempts: false,
        lastLoginField: 'last',
        attemptsField: 'attempts',
        interval: 100,
        maxInterval: 300000,
        maxAttempts: Infinity,
        unlockInterval: undefined,
        passwordValidator: (_password) => Promise.resolve(),
        findByUsername: (model, queryParameters) => model.findOne(queryParameters),
        selectFields: undefined,
        populateFields: undefined,
        errorMessages: {},
        ...options,
    };
    // Set default error messages
    opts.errorMessages.MissingPasswordError = opts.errorMessages.MissingPasswordError || 'No password was given';
    opts.errorMessages.AttemptTooSoonError = opts.errorMessages.AttemptTooSoonError || 'Account is currently locked. Try again later';
    opts.errorMessages.TooManyAttemptsError =
        opts.errorMessages.TooManyAttemptsError || 'Account locked due to too many failed login attempts';
    opts.errorMessages.NoSaltValueStoredError =
        opts.errorMessages.NoSaltValueStoredError || 'Authentication not possible. No salt value stored';
    opts.errorMessages.IncorrectPasswordError = opts.errorMessages.IncorrectPasswordError || 'Password or username is incorrect';
    opts.errorMessages.IncorrectUsernameError = opts.errorMessages.IncorrectUsernameError || 'Password or username is incorrect';
    opts.errorMessages.MissingUsernameError = opts.errorMessages.MissingUsernameError || 'No username was given';
    opts.errorMessages.UserExistsError = opts.errorMessages.UserExistsError || 'A user with the given username is already registered';
    // Populate username query fields
    if (options?.usernameQueryFields) {
        opts.usernameQueryFields.push(...options.usernameQueryFields, opts.usernameField);
    }
    else {
        opts.usernameQueryFields = [opts.usernameField];
    }
    const schemaFields = {};
    if (!schema.path(opts.usernameField)) {
        schemaFields[opts.usernameField] = { type: String, unique: opts.usernameUnique };
    }
    schemaFields[opts.hashField] = { type: String, select: false };
    schemaFields[opts.saltField] = { type: String, select: false };
    if (opts.limitAttempts) {
        schemaFields[opts.attemptsField] = { type: Number, default: 0 };
        schemaFields[opts.lastLoginField] = { type: Date, default: Date.now };
    }
    schema.add(schemaFields);
    schema.pre('save', function () {
        if (opts.usernameLowerCase && this.get(opts.usernameField)) {
            this.set(opts.usernameField, this.get(opts.usernameField).toLowerCase());
        }
    });
    schema.methods.setPassword = async function (password) {
        if (!password) {
            throw new errors.MissingPasswordError(opts.errorMessages.MissingPasswordError);
        }
        await opts.passwordValidator(password);
        const saltBuffer = await randomBytesAsync(opts.saltlen);
        const salt = saltBuffer.toString(opts.encoding);
        this.set(opts.saltField, salt);
        const hashRaw = await (0, pbkdf2_1.pbkdf2)(password, salt, opts);
        this.set(opts.hashField, Buffer.from(hashRaw).toString(opts.encoding));
        return this;
    };
    schema.methods.changePassword = async function (oldPassword, newPassword) {
        if (!oldPassword || !newPassword) {
            throw new errors.MissingPasswordError(opts.errorMessages.MissingPasswordError);
        }
        const { user, error } = await this.authenticate(oldPassword);
        if (!user) {
            throw error;
        }
        await this.setPassword(newPassword);
        await this.save();
        return this;
    };
    schema.methods.authenticate = async function (password) {
        if (this.get(opts.saltField)) {
            return await (0, authenticate_1.authenticate)(this, password, opts);
        }
        const ThisModel = this.constructor;
        const user = await ThisModel.findByUsername(this.get(opts.usernameField), true);
        if (user) {
            return await (0, authenticate_1.authenticate)(user, password, opts);
        }
        return { user: false, error: new errors.IncorrectUsernameError(opts.errorMessages.IncorrectUsernameError) };
    };
    if (opts.limitAttempts) {
        schema.methods.resetAttempts = async function () {
            this.set(opts.attemptsField, 0);
            return await this.save();
        };
    }
    // Passport Local Interface
    schema.statics.authenticate = function () {
        return (username, password, cb) => {
            const promise = Promise.resolve()
                .then(() => this.findByUsername(username, true))
                .then((user) => {
                if (user) {
                    return user.authenticate(password);
                }
                return { user: false, error: new errors.IncorrectUsernameError(opts.errorMessages.IncorrectUsernameError) };
            });
            if (!cb) {
                return promise;
            }
            return promise.then(({ user, error }) => cb(null, user, error)).catch((err) => cb(err));
        };
    };
    // Passport Interface
    schema.statics.serializeUser = function () {
        return function (user, cb) {
            cb(null, user.get(opts.usernameField));
        };
    };
    schema.statics.deserializeUser = function () {
        return async (username, cb) => {
            try {
                const user = await this.findByUsername(username);
                cb(null, user);
            }
            catch (err) {
                cb(err);
            }
        };
    };
    schema.statics.register = async function (user, password) {
        // Create an instance of this in case user isn't already an instance
        if (!(user instanceof this)) {
            user = new this(user);
        }
        if (!user.get(opts.usernameField)) {
            throw new errors.MissingUsernameError(opts.errorMessages.MissingUsernameError);
        }
        const existingUser = await this.findByUsername(user.get(opts.usernameField));
        if (existingUser) {
            throw new errors.UserExistsError(opts.errorMessages.UserExistsError);
        }
        await user.setPassword(password);
        return await user.save();
    };
    schema.statics.findByUsername = function (username, selectOrOpts) {
        let selectOpts = {};
        if (typeof selectOrOpts === 'boolean') {
            selectOpts = {
                selectHashSaltFields: selectOrOpts,
            };
        }
        else if (selectOrOpts) {
            selectOpts = selectOrOpts;
        }
        selectOpts.selectHashSaltFields = !!selectOpts.selectHashSaltFields;
        // if specified, convert the username to lowercase
        let queryUsername = username;
        if (username !== undefined && opts.usernameLowerCase) {
            queryUsername = username.toLowerCase();
        }
        // escape regex tokens
        if (username !== undefined && opts.usernameCaseInsensitive) {
            queryUsername = username.replace(/[!#$()*+\-./:<=>?[\\\]^{|}]/g, '\\$&');
        }
        // Add each username query field
        const queryOrParameters = [];
        for (let i = 0; i < opts.usernameQueryFields.length; i++) {
            const parameter = {};
            parameter[opts.usernameQueryFields[i]] = opts.usernameCaseInsensitive ? new RegExp(`^${queryUsername}$`, 'i') : queryUsername;
            queryOrParameters.push(parameter);
        }
        const query = opts.findByUsername(this, { $or: queryOrParameters });
        if (selectOpts.selectHashSaltFields) {
            query.select('+' + opts.hashField + ' +' + opts.saltField);
        }
        if (opts.selectFields) {
            query.select(opts.selectFields);
        }
        if (opts.populateFields) {
            query.populate(opts.populateFields);
        }
        return query;
    };
    schema.statics.createStrategy = function () {
        return new passport_local_1.Strategy(opts, this.authenticate());
    };
}
passportLocalMongoose.errors = errors;
exports.default = passportLocalMongoose;
//# sourceMappingURL=index.js.map